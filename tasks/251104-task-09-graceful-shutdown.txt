TASK-09: Implement Graceful Shutdown for All Services

## Objective

Implement graceful shutdown endpoints and signal handling for all long-running processes in Hephaestus to ensure clean restarts after code changes.

## Background

**Problem:** Stale processes running old code after changes to source files, configuration, or dependencies.

**Solution:** Implement standard health and shutdown endpoints that allow processes to be gracefully stopped and restarted.

## Requirements

### 0. Centralized Server State

All services must maintain centralized state:

```python
from datetime import datetime

class ServerState:
    """Centralized server state (singleton)"""
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.start_time = datetime.utcnow()
            cls._instance.should_shutdown = False
        return cls._instance

    @property
    def uptime_seconds(self) -> float:
        return (datetime.utcnow() - self.start_time).total_seconds()

    def request_shutdown(self):
        """Set shutdown flag"""
        self.should_shutdown = True

# Global singleton
server_state = ServerState()
```

### 1. Health Endpoints (MinIO-style)

All services must implement multiple health endpoints:

**Basic health check:**
```python
@app.get("/health/live")
async def health_live():
    return {
        "status": "healthy" if not server_state.should_shutdown else "shutting_down",
        "uptime_seconds": server_state.uptime_seconds,
        "start_time": server_state.start_time.isoformat(),
        "version": __version__,
        "service": "hephaestus-mcp"
    }
```

**Detailed status (MinIO-style):**
```python
@app.get("/health/status")
async def health_status():
    """
    Detailed status showing state of all dependencies.
    Each dependency reports: "working", "error", or "not_used"
    """
    return {
        "status": "healthy" if not server_state.should_shutdown else "shutting_down",
        "uptime_seconds": server_state.uptime_seconds,
        "start_time": server_state.start_time.isoformat(),
        "version": __version__,
        "service": "hephaestus-mcp",
        "should_shutdown": server_state.should_shutdown,
        "dependencies": {
            "database": {
                "status": await get_database_status(),  # "working", "error", or "not_used"
                "pool_size": await get_connection_pool_size() if database_enabled else None,
                "error": await get_database_error() if database_error else None,
                "last_success_seconds": await get_database_last_success(),  # seconds since success, or -1 if never
                "last_failure_seconds": await get_database_last_failure(),  # seconds since failure, or -1 if never
                "success_count": await get_database_success_count(),  # total successes since startup
                "failure_count": await get_database_failure_count()   # total failures since startup
            },
            "qdrant": {
                "status": await get_qdrant_status(),  # "working", "error", or "not_used"
                "collections": await get_collection_count() if qdrant_enabled else None,
                "error": await get_qdrant_error() if qdrant_error else None,
                "last_success_seconds": await get_qdrant_last_success(),
                "last_failure_seconds": await get_qdrant_last_failure(),
                "success_count": await get_qdrant_success_count(),
                "failure_count": await get_qdrant_failure_count()
            },
            "openai": {
                "status": await get_openai_status(),  # "working", "error", or "not_used"
                "embedding_model": config.openai_embedding_model if openai_enabled else None,
                "error": await get_openai_error() if openai_error else None,
                "last_success_seconds": await get_openai_last_success(),
                "last_failure_seconds": await get_openai_last_failure(),
                "success_count": await get_openai_success_count(),
                "failure_count": await get_openai_failure_count()
            },
            "anthropic": {
                "status": await get_anthropic_status(),  # "working", "error", or "not_used"
                "provider": config.claude_code_provider if anthropic_enabled else None,
                "error": await get_anthropic_error() if anthropic_error else None,
                "last_success_seconds": await get_anthropic_last_success(),
                "last_failure_seconds": await get_anthropic_last_failure(),
                "success_count": await get_anthropic_success_count(),
                "failure_count": await get_anthropic_failure_count()
            },
            "lmstudio": {
                "status": await get_lmstudio_status(),  # "working", "error", or "not_used"
                "embedding_enabled": config.embedding_provider == "lmstudio",
                "review_enabled": config.code_review_provider == "lmstudio",
                "error": await get_lmstudio_error() if lmstudio_error else None,
                "last_success_seconds": await get_lmstudio_last_success(),
                "last_failure_seconds": await get_lmstudio_last_failure(),
                "success_count": await get_lmstudio_success_count(),
                "failure_count": await get_lmstudio_failure_count()
            },
            "groq": {
                "status": await get_groq_status(),  # "working", "error", or "not_used"
                "review_enabled": config.code_review_provider == "groq",
                "error": await get_groq_error() if groq_error else None,
                "last_success_seconds": await get_groq_last_success(),
                "last_failure_seconds": await get_groq_last_failure(),
                "success_count": await get_groq_success_count(),
                "failure_count": await get_groq_failure_count()
            }
        },
        "resources": {
            "open_connections": await get_open_connections(),
            "background_tasks": await get_background_task_count()
        }
    }
```

**Returns:**
- status: "healthy" or "shutting_down" (NOT "degraded" - use dependency status instead)
- uptime_seconds: Time since service started
- start_time: ISO 8601 timestamp when service started
- version: Service version
- service: Service name
- should_shutdown: Boolean flag indicating shutdown requested
- dependencies: Object with status for each dependency
  - Each dependency has status: "working", "error", or "not_used"
  - If error, includes error field with details
  - If not_used, other fields are null/omitted
  - last_success_seconds: Seconds since last successful operation (-1 if never succeeded)
  - last_failure_seconds: Seconds since last failed operation (-1 if never failed)
  - success_count: Total successful operations since startup
  - failure_count: Total failed operations since startup

### 2. Shutdown Endpoints (Two Options)

**Option A: Immediate blocking shutdown - `POST /health/shutdown`**

Blocks until shutdown is complete:

```python
@app.post("/health/shutdown")
async def shutdown():
    """
    Gracefully shutdown the service immediately.
    Blocks until shutdown is complete.
    """
    logger.info("Immediate shutdown requested via /shutdown endpoint")

    # 1. Set shutdown flag
    server_state.request_shutdown()

    # 2. Stop accepting new requests
    await set_service_state("shutting_down")

    # 3. Wait for in-flight requests to complete (with timeout)
    await wait_for_requests(timeout=30)

    # 4. Clean up resources
    await cleanup_database_connections()
    await cleanup_file_handles()
    await cleanup_background_tasks()

    # 5. Flush logs
    await flush_logs()

    # 6. Return success (blocks until complete)
    return {
        "status": "shutdown_complete",
        "cleanup_duration_seconds": cleanup_time,
        "mode": "immediate"
    }
```

**Behavior:**
- Sets should_shutdown flag immediately
- Blocks until shutdown is complete
- Returns HTTP 200 when ready to terminate
- Ensures all cleanup is done before returning
- Logs shutdown progress

**Option B: Scheduled shutdown - `POST /health/shutdown/schedule`**

Sets shutdown flag and returns immediately:

```python
@app.post("/health/shutdown/schedule")
async def shutdown_schedule():
    """
    Schedule graceful shutdown.
    Returns immediately, shutdown happens asynchronously.
    """
    logger.info("Scheduled shutdown requested via /shutdown/schedule endpoint")

    # Set shutdown flag
    server_state.request_shutdown()

    # Schedule shutdown in background
    asyncio.create_task(perform_graceful_shutdown())

    # Return immediately
    return {
        "status": "shutdown_scheduled",
        "should_shutdown": True,
        "mode": "scheduled",
        "message": "Shutdown will occur after current requests complete"
    }

async def perform_graceful_shutdown():
    """Background task to perform shutdown"""
    # Wait for in-flight requests
    await wait_for_requests(timeout=30)

    # Clean up resources
    await cleanup_database_connections()
    await cleanup_file_handles()
    await cleanup_background_tasks()

    # Flush logs
    await flush_logs()

    # Exit
    logger.info("Scheduled shutdown complete, exiting")
    sys.exit(0)
```

**Behavior:**
- Sets should_shutdown flag immediately
- Returns HTTP 200 immediately
- Shutdown happens in background
- Allows monitoring via /health (shows "shutting_down" status)
- Good for graceful shutdown without blocking client

### 3. Signal Handling

All services must handle SIGTERM and SIGINT:

```python
import signal
import asyncio

async def graceful_shutdown(signum, frame):
    """Handle shutdown signals"""
    logger.info(f"Received signal {signum}, initiating graceful shutdown")

    # Same cleanup as /shutdown endpoint
    await cleanup_resources()
    await shutdown_server()

    # Exit cleanly
    sys.exit(0)

# Register signal handlers
signal.signal(signal.SIGTERM, lambda s, f: asyncio.create_task(graceful_shutdown(s, f)))
signal.signal(signal.SIGINT, lambda s, f: asyncio.create_task(graceful_shutdown(s, f)))
```

### 4. Resource Cleanup

All services must implement cleanup for:

1. **Database connections:**
   ```python
   async def cleanup_database_connections():
       await db_manager.close_all_connections()
       await db_manager.dispose_engine()
   ```

2. **File handles:**
   ```python
   async def cleanup_file_handles():
       for handle in open_file_handles:
           await handle.close()
   ```

3. **Background tasks:**
   ```python
   async def cleanup_background_tasks():
       for task in background_tasks:
           task.cancel()
           try:
               await task
           except asyncio.CancelledError:
               pass
   ```

4. **Log flushing:**
   ```python
   async def flush_logs():
       for handler in logging.root.handlers:
           handler.flush()
   ```

## Implementation Plan

### Phase 1: MCP Server (src/mcp/server.py)

1. Add /health endpoint
2. Add /shutdown endpoint
3. Implement signal handlers
4. Implement resource cleanup functions
5. Test graceful shutdown

### Phase 2: Background Services

1. Identify all long-running background services
2. Implement health/shutdown for each
3. Add signal handling
4. Test graceful shutdown

### Phase 3: Testing

1. Test /health endpoint returns correct status
2. Test /shutdown blocks until complete
3. Test SIGTERM triggers graceful shutdown
4. Test resource cleanup (no leaked connections/files)
5. Test restart after shutdown

### Phase 4: Documentation

1. Update CLAUDE.md with shutdown procedures
2. Document standard endpoints
3. Add examples to README

## Acceptance Criteria

1. All services respond to GET /health
2. All services respond to POST /shutdown
3. /shutdown blocks until cleanup is complete
4. SIGTERM/SIGINT trigger graceful shutdown
5. No resource leaks after shutdown
6. Services can be restarted cleanly
7. Documentation updated

## Endpoint Summary

All services must implement these endpoints:

1. **GET /health/live** - Basic health check (uptime, status, start_time)
2. **GET /health/status** - Detailed status (MinIO-style with resource info)
3. **POST /health/shutdown** - Immediate graceful shutdown (blocks until complete)
4. **POST /health/shutdown/schedule** - Scheduled shutdown (returns immediately, sets flag)

## Testing

```bash
# Test basic health endpoint
curl http://localhost:8000/health/live
# Expected: {"status":"healthy","uptime_seconds":123.45,"start_time":"2025-11-04T12:00:00",...}

# Test detailed status endpoint
curl http://localhost:8000/health/status
# Expected: Full status with database, qdrant, and resource info

# Test scheduled shutdown (non-blocking)
curl -X POST http://localhost:8000/health/shutdown/schedule
# Expected: {"status":"shutdown_scheduled","should_shutdown":true,"mode":"scheduled"}

# Verify shutdown flag was set
curl http://localhost:8000/health/live
# Expected: {"status":"shutting_down",...}

# Test immediate shutdown (blocking)
curl -X POST http://localhost:8000/health/shutdown
# Expected: Blocks until shutdown complete, then returns {"status":"shutdown_complete",...}

# Test signal handling
kill -TERM <pid>

# Verify clean exit
echo $?  # Should be 0
```

## Files to Modify

- src/mcp/server.py
- src/monitoring/monitor.py (if applicable)
- src/agents/manager.py (if applicable)
- .claude/CLAUDE.md (already updated)

## Notes

- Shutdown timeout: 30 seconds for in-flight requests
- Health check interval: Should be configurable
- Graceful shutdown is CRITICAL for clean restarts
- Never kill -9 (SIGKILL) - always use SIGTERM first

## Estimated Time

4-6 hours

## Priority

HIGH - Required for reliable development workflow

## Dependencies

None
